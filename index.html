<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite + TS</title>
  <script src="/framework-load.js"></script>
  <script type="module" src="/src/main.ts"></script>
</head>

<body>
  <script>window.pageprops = { name: 'Tommy' }</script>

  <main id="app" x-load>
    <!-- <div>

      <h1>Way.js - A Web-framework</h1>
      <p>written by {name}</p>

      <h2>
        Signals x WebComponents <br>
        = the Way
      </h2>

      <ul>
        <li>
          everything is done via html attributes, just write html! no jsx, no vdom
        </li>
        <li>
          we can still write jsx the nice way
          &lt;Counter /&gt; by using webcomponents, just for templating
        </li>
        <li>
          fine-grained reactivity through signals, updating the dom when needed
        </li>
        <li>
          the rest is just vanilla js, attach events to dom nodes
        </li>
      </ul>

      <p>
        I love alpine, its basically vue, but everything is via html attributes. So you can just write normal html. no
        jsx, no build step
      </p>

      <p>
        BUT <br />
        it has no components, the assumption is you're server rendering everything, and just sprinkling in some
        reactivity
        via attributes. <br>
        but what if we want to write a little more frontend functionality, doesn't feel great building complex pages
        with
        alpine.
      </p>
    </div> -->


    <!-- <h2>1. this is just alpine with signals</h2>
    <div x-comp="{x:1}">
      <p>
        {x} x 3 = {x.value*3}
      </p>
      <button @click="x.value = x.value+1">+1</button>
      <h3>
        conditional logic
      </h3>
      <p :style="{ color: x%2===0 ?'blue':'black' }">
        <template x-if="x%2==0">even</template>
        <template x-else>uneven</template>
      </p>
      <h3>and for loops</h3>
      <ul class="for-list" :style="{'font-size': `${24-x*0.5}px`}">
        <template x-for="(i,j) in Array(x.value).fill(0)">
          <li key="j">
            {j+1}
          </li>
        </template>
      </ul>
    </div> -->

    <!-- <div>
      <h2>2. reusable data</h2>
      <p>but for larger apps we have loads of javascript that doesnt really fit into attributes, so we want js logic, so
        just write them the same way as vue3 setup components. we can now write complex js, in separate file, or inline,
        and reuse this data logic</p>
    </div> -->

    <pre>
      Way.comp('counter', () => {
      const count = signal(0);
      const double = computed(() => count.value * 2);
      const incr = () => count.value++;
      const decr = () => count.value--;
      return { count, double, incr, decr };
      });
    </pre>
    <script>
      way.comp('counter', () => {
        const count = way.signal(0);
        const double = way.computed(() => count.value * 2);
        const incr = () => count.value++;
        const decr = () => count.value--;
        return { count, double, incr, decr };
      });
    </script>

    <div x-comp="counter">
      <h3>counter</h3>
      <p :style="{'--x': count}">
        count A : {count}
        x 2 = {double}
      </p>
      <button @click="incr()">+</button>
      <button @click="decr()">-</button>

    </div>

    <div x-comp="counter">
      <h3>reuse for another counter </h3>
      <p>Counter B : {count}</p>
      <button @click="incr()"> +1</button>
    </div>

    <h2>components</h2>
    <p>
      ok but if we need to write something slightly bigger, we just have one huge nestede html, tracking state gets
      confusing, and no reusable tempaltes or components for repeating logic
    </p>

    <h3>Web components</h3>
    <p>so we create components with web components and write their content in templates, for reusable components that
      have both logic + html</p>
    <p>and bonus, for us framework brains, this looks like using components in framework jsx </p>

    <my-clock x-props="{seconds:true}"></my-clock>

    <h2>Props</h2>
    <p>but components receive props so we can pass them signals and write complex reactive logic</p>

    <div x-comp="counter">
      <h3>reuse for another of our counter components, and pass the 'count' as a prop </h3>
      <p>Counter C : {count}</p>
      <button @click="incr()"> +1</button>
      <count-down x-props="{start: count}" />
    </div>

    <!-- <h2>Forms</h2>
    <p>frameworks can natively bind to inputs, but input validation is such an important part in everyday framworking,
      i just baked it right in. simplify define x-form with zod schema, inspired by vee-validate.</p>
    <form x-form="login" x-comp="{name: ''}">
      <p>Hi {name}</p>
      <label>
        Name:
        <input x-model="name" name="name" aria-describedby="nameerror" />
      </label>
      <p id="nameerror"></p>

      <label>
        password:
        <input name="password" aria-describedby="passworderror" />
      </label>
      <p id="passworderror"></p>
      <button>Submit</button>
    </form> -->

    <!-- <h2>The result - Way</h2>
      <p>i mean, is it even a js framework? i'd prefer to call it a web-framework</p>

      <ul>
        <li>no jsx!</li>
        <li>technically its vanilla js + web components + signals - html first!</li>
        <li>web platform first! </li>
      </ul> -->
  </main>

  <template id="my-clock">
    <p>
      The time is {time}
    </p>
  </template>
  <script>
    way.comp('my-clock', ({ }, props) => {
      const time = way.signal(gettime())

      function gettime() {
        const d = new Date();
        const h = d.getHours().toString()
        const m = d.getMinutes().toString().padStart(2, '0')
        const s = d.getSeconds().toString().padStart(2, '0')
        let t = `${h}:${m}`
        if (props.seconds) t += `:${s}`
        return t
      }

      setInterval(() => {
        time.value = gettime()
      }, 1000);
      return {
        time
      }
    })
  </script>

  <template id="count-down">
    <p>
      countdown! : {countdown}
    </p>
  </template>

  <script>
    way.comp('count-down', ({ }, props) => {
      const start = props.start
      const countdown = way.signal(start.value)
      let intvl;

      const runcountdown = () => {
        if (intvl) clearInterval(intvl)
        countdown.value = start.value
        intvl = setInterval(() => {
          if (countdown.value > 0) {
            countdown.value -= 1
          }
          else {
            clearInterval(intvl)
          }
        }, 500);
      }

      way.effect(() => {
        runcountdown()
      })

      return { countdown }
    })
  </script>

  <template id="card">
    <div style="border: 1px solid #ccc; padding: 16px; margin: 16px 0;">
      <h3>Card</h3>
      <slot></slot>
    </div>
  </template>
  <!-- 
  <div x-temp="card">
    <p>This is the content that will be slotted into the card.</p>
  </div> -->


  <style>
    [x-load] {
      display: none;
    }
  </style>
</body>

</html>