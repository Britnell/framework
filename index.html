<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="/vite.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Vite + TS</title>
  <script src="/framework-load.js"></script>
  <script type="module" src="/src/main.ts"></script>
</head>

<body>
  <style>
    [x-load] {
      display: none;
    }

    .for-list {
      list-style: none;
      display: flex;
      gap: 2px;
    }
  </style>

  <script>window.pageprops = { name: 'Tommy' }</script>
  <main id="app" x-load>
    <h1>Way - A Web-framework</h1>
    <p>writen by {name}</p>
    <h2>1. this is just alpine with signals</h2>
    <div x-data="{x:1}">
      <p>
        {x} x 3 = {x.value*3}
      </p>
      <button @click="x.value = x.value+1">+1</button>
      <h3>
        conditional logic
      </h3>
      <p :style="{ color: x%2===0 ?'blue':'black' }">
        <template x-if="x%2==0">even</template>
        <template x-else>uneven</template>
      </p>
      <h3>and for loops</h3>
      <ul class="for-list" :style="{'font-size': `${24-x*0.5}px`}">
        <template x-for="(i,j) in Array(x.value).fill(0)">
          <li key="j">
            {j+1}
          </li>
        </template>
      </ul>
    </div>

    <h2>2. reusable data</h2>
    <p>but for larger apps we have loads of javascript that doesnt really fit into attributes, so we want js logic, so
      just write them the same way as vue3 setup components. we can now write complex js, in separate file, or inline,
      and reuse this data logic</p>

    <p>
      Way.comp('counter', () => {
      const count = signal(0);
      const double = computed(() => count.value * 2);
      const incr = () => count.value++;
      const decr = () => count.value--;
      return { count, double, incr, decr };
      });
    </p>

    <div x-data="counter">
      <h3>counter</h3>
      <p :style="{'--x': count}">
        count A : {count}
        x 2 = {double}
      </p>
      <button @click="incr()">+</button>
      <button @click="decr()">-</button>

    </div>

    <div x-data="counter">
      <h3>reuse for another counter </h3>
      <p>Counter B : {count}</p>
      <button @click="incr()"> +1</button>
    </div>

    <h2>components</h2>
    <p>
      ok but if we need to write something slightly bigger, we just have one huge nestede html, tracking state gets
      confusing, and no reusable tempaltes or components for repeating logic
    </p>

    <div>
      <h3>Web components</h3>
      <p>so we create components with web components and write their content in templates, for reusable components that
        have both logic + html</p>
      <p>and bonus, for us framework brains, this looks like using components in framework jsx </p>

      <my-clock x-props="{seconds:true}" />
      <template id="my-clock">
        <p>
          The time is {time}
        </p>
      </template>
      <script>
        way.comp('my-clock', ({ }, props) => {
          const time = way.signal(gettime())

          function gettime() {
            const d = new Date();
            const h = d.getHours().toString()
            const m = d.getMinutes().toString().padStart(2, '0')
            const s = d.getSeconds().toString().padStart(2, '0')
            let t = `${h}:${m}`
            if (props.seconds) t += `:${s}`
            return t
          }

          setInterval(() => {
            time.value = gettime()
          }, 1000);
          return {
            time
          }
        })
      </script>
    </div>

    <h2>Props</h2>
    <p>but components receive props so we can pass them signals and write complex reactive logic</p>

    <div x-data="counter">
      <h3>reuse for another of our counter components, and pass the 'count' as a prop </h3>
      <p>Counter C : {count}</p>
      <button @click="incr()"> +1</button>
      <count-down x-props="{start: count}" />
    </div>

    <template id="count-down">
      <p>
        countdown! : {countdown}
      </p>
    </template>
    <script>
      way.comp('count-down', ({ }, props) => {
        const start = props.start
        const countdown = way.signal(start.value)
        let intvl;

        const runcountdown = () => {
          if (intvl) clearInterval(intvl)
          countdown.value = start.value
          intvl = setInterval(() => {
            if (countdown.value > 0) {
              countdown.value -= 1
            }
            else {
              clearInterval(intvl)
            }
          }, 500);
        }

        way.effect(() => {
          runcountdown()
        })

        return { countdown }
      })
    </script>



    <h2>The result - Way</h2>
    <p>i mean, is it even a js framework? i'd prefer to call it a web-framework</p>

    <ul>
      <li>no jsx!</li>
      <li>technically its vanilla js + web components + signals - html first!</li>
      <li>web platform first! </li>
    </ul>
  </main>






  <template id="card">
    <div style="border: 1px solid #ccc; padding: 16px; margin: 16px 0;">
      <h3>Card</h3>
      <slot></slot>
    </div>
  </template>

  <div x-temp="card">
    <p>This is the content that will be slotted into the card.</p>
  </div>

</body>

</html>